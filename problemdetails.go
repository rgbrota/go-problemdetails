package problemdetails

import (
	"encoding/xml"
	"net/http"
	"strings"
)

const defaultProblemType = "about:blank"

// ProblemDetails is the struct definition of a problem details object as defined by
// the RFC7807 with an extension field to include a list of errors.
type ProblemDetails struct {
	XMLName xml.Name `json:"-" xml:"urn:ietf:rfc:7807 problem"`
	//   Type is a URI reference [RFC3986] that identifies the
	//   problem type. This specification encourages that, when
	//   dereferenced, it provide human-readable documentation for the
	//   problem type (e.g., using HTML [W3C.REC-html5-20141028]). When
	//   this member is not present, its value is assumed to be
	//   "about:blank".
	Type string `json:"type" xml:"type"`
	//   Title is a short, human-readable summary of the problem
	//   type. It SHOULD NOT change from occurrence to occurrence of the
	//   problem, except for purposes of localization (e.g., using
	//   proactive content negotiation; see [RFC7231], Section 3.4).
	Title string `json:"title" xml:"title"`
	//   Status is the HTTP status code ([RFC7231], Section 6)
	//   generated by the origin server for this occurrence of the problem.
	Status int `json:"status,omitempty" xml:"status,omitempty"`
	//   Detail is a human-readable explanation specific to this
	//   occurrence of the problem.
	Detail string `json:"detail,omitempty" xml:"detail,omitempty"`
	//   Instance is a URI reference that identifies the specific
	//   occurrence of the problem. It may or may not yield further
	//   information if dereferenced.
	Instance string `json:"instance,omitempty" xml:"instance,omitempty"`
	//   Errors is an extension field where the errors associated with
	//   this instance can be provided.
	Errors []any `json:"errors,omitempty" xml:"errors,omitempty"`
}

// New creates a new ProblemDetails
func New(problemType string, title string, statusCode int, detail string, instance string, errors []any) *ProblemDetails {
	if strings.TrimSpace(problemType) == "" {
		return &ProblemDetails{
			Type:     defaultProblemType,
			Title:    http.StatusText(statusCode),
			Status:   statusCode,
			Detail:   detail,
			Instance: instance,
			Errors:   errors,
		}
	}

	return &ProblemDetails{
		Type:     problemType,
		Title:    title,
		Status:   statusCode,
		Detail:   detail,
		Instance: instance,
		Errors:   errors,
	}
}

// FromHTTPStatus creates a new ProblemDetails based on the HTTP status code provided
func FromHTTPStatus(statusCode int) *ProblemDetails {
	return New("", "", statusCode, "", "", make([]any, 0))
}
